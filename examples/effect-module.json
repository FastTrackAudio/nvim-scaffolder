{
  "name": "Effect Module Template",
  "description": "Creates a complete Effect-based module structure with service, hooks, tests and types",
  "folder_case": "kebab",
  "files": [
    {
      "path": "${folder_name}/index.ts",
      "content": [
        "export * from './${name:kebab}.service';",
        "export * from './${name:kebab}.hooks';",
        "export * from './types/${name:kebab}.type';"
      ]
    },
    {
      "path": "${folder_name}/${name:kebab}.service.ts",
      "content": [
        "import { ${name:pascal}, ${name:pascal}Id } from \"./types/${name:kebab}.type\";",
        "import { Array, Chunk, DateTime, Effect, Random, Schedule } from \"effect\";",
        "",
        "/**",
        " * Service for handling ${name:pascal} operations",
        " */",
        "export class ${name:pascal}Service extends Effect.Service<${name:pascal}Service>()(\"{${name:pascal}Service}\", {",
        "  accessors: true,",
        "  dependencies: [],",
        "  effect: Effect.gen(function* () {",
        "    /**",
        "     * Get a ${name:camel} by ID",
        "     */",
        "    const get = (id: ${name:pascal}Id) =>",
        "      Effect.succeed({ id, name: \"Test ${name:pascal}\" });",
        "",
        "    /**",
        "     * Create a new ${name:camel}",
        "     */",
        "    const create = (data: Omit<${name:pascal}, \"id\">) =>",
        "      Effect.succeed({",
        "        id: Random.nextUUID as unknown as ${name:pascal}Id,",
        "        ...data,",
        "        createdAt: new Date(),",
        "        updatedAt: new Date()",
        "      });",
        "",
        "    /**",
        "     * Update an existing ${name:camel}",
        "     */",
        "    const update = (id: ${name:pascal}Id, data: Partial<${name:pascal}>) =>",
        "      Effect.succeed({",
        "        id,",
        "        name: \"Updated ${name:pascal}\",",
        "        ...data,",
        "        updatedAt: new Date()",
        "      });",
        "",
        "    /**",
        "     * Delete a ${name:camel}",
        "     */",
        "    const remove = (id: ${name:pascal}Id) =>",
        "      Effect.succeed({ success: true });",
        "",
        "    return {",
        "      get,",
        "      create,",
        "      update,",
        "      remove",
        "    };",
        "  }),",
        "}) {}"
      ]
    },
    {
      "path": "${folder_name}/${name:kebab}.hooks.ts",
      "content": [
        "/**",
        " * React hooks for ${name:kebab}",
        " */",
        "import { useEffect, useState } from 'react';",
        "import { Effect, pipe, Either } from 'effect';",
        "import { ${name:pascal}, ${name:pascal}Id } from './types/${name:kebab}.type';",
        "import { ${name:pascal}Service } from './${name:kebab}.service';",
        "",
        "/**",
        " * Hook to fetch a ${name:camel} by ID using the Effect pattern",
        " */",
        "export const use${name:pascal} = (id: ${name:pascal}Id) => {",
        "  const [state, setState] = useState<{",
        "    ${name:camel}: ${name:pascal} | null;",
        "    loading: boolean;",
        "    error: Error | null;",
        "  }>({",
        "    ${name:camel}: null,",
        "    loading: true,",
        "    error: null",
        "  });",
        "",
        "  useEffect(() => {",
        "    let mounted = true;",
        "",
        "    // Use the Effect service to fetch data",
        "    const effect = ${name:pascal}Service.get(id);",
        "",
        "    // Run the effect and handle the result",
        "    Effect.runPromiseEither(effect).then((result) => {",
        "      if (!mounted) return;",
        "",
        "      if (Either.isLeft(result)) {",
        "        setState({",
        "          ${name:camel}: null,",
        "          loading: false,",
        "          error: result.left",
        "        });",
        "      } else {",
        "        setState({",
        "          ${name:camel}: result.right,",
        "          loading: false,",
        "          error: null",
        "        });",
        "      }",
        "    });",
        "",
        "    return () => {",
        "      mounted = false;",
        "    };",
        "  }, [id]);",
        "",
        "  return state;",
        "};"
      ]
    },
    {
      "path": "${folder_name}/types/${name:kebab}.type.ts",
      "content": [
        "import { Brand } from 'effect';",
        "",
        "/**",
        " * Type definitions for ${name:kebab}",
        " */",
        "",
        "/**",
        " * Branded ID type for ${name:pascal}",
        " */",
        "export type ${name:pascal}Id = Brand.Brand<string, '${name:pascal}Id'>;",
        "",
        "/**",
        " * Create a branded ID from a string",
        " */",
        "export const ${name:pascal}Id = (id: string): ${name:pascal}Id => ",
        "  Brand.nominal<${name:pascal}Id>(id);",
        "",
        "/**",
        " * Main ${name:pascal} type",
        " */",
        "export interface ${name:pascal} {",
        "  id: ${name:pascal}Id;",
        "  name: string;",
        "  description?: string;",
        "  createdAt: Date;",
        "  updatedAt: Date;",
        "  metadata?: Record<string, unknown>;",
        "}",
        "",
        "/**",
        " * ${name:pascal} creation parameters",
        " */",
        "export type ${name:pascal}CreateInput = Omit<${name:pascal}, 'id' | 'createdAt' | 'updatedAt'>;",
        "",
        "/**",
        " * ${name:pascal} update parameters",
        " */",
        "export type ${name:pascal}UpdateInput = Partial<${name:pascal}CreateInput>;"
      ]
    },
    {
      "path": "${folder_name}/__tests__/${name:kebab}.service.test.ts",
      "content": [
        "/**",
        " * Tests for ${name:kebab}.service",
        " */",
        "import { Effect } from 'effect';",
        "import { ${name:pascal}Service } from '../${name:kebab}.service';",
        "import { ${name:pascal}Id } from '../types/${name:kebab}.type';",
        "",
        "describe('${name:pascal}Service', () => {",
        "  describe('get', () => {",
        "    it('should retrieve a ${name:camel} by ID', async () => {",
        "      const id = ${name:pascal}Id('test-id');",
        "      const effect = ${name:pascal}Service.get(id);",
        "      const result = await Effect.runPromise(effect);",
        "      ",
        "      expect(result).toBeDefined();",
        "      expect(result.id).toBe(id);",
        "    });",
        "  });",
        "",
        "  describe('create', () => {",
        "    it('should create a new ${name:camel}', async () => {",
        "      const data = { name: 'Test ${name:pascal}' };",
        "      const effect = ${name:pascal}Service.create(data);",
        "      const result = await Effect.runPromise(effect);",
        "      ",
        "      expect(result).toBeDefined();",
        "      expect(result.id).toBeDefined();",
        "      expect(result.name).toBe('Test ${name:pascal}');",
        "      expect(result.createdAt).toBeInstanceOf(Date);",
        "    });",
        "  });",
        "",
        "  describe('update', () => {",
        "    it('should update an existing ${name:camel}', async () => {",
        "      const id = ${name:pascal}Id('test-id');",
        "      const data = { name: 'Updated ${name:pascal}' };",
        "      const effect = ${name:pascal}Service.update(id, data);",
        "      const result = await Effect.runPromise(effect);",
        "      ",
        "      expect(result).toBeDefined();",
        "      expect(result.id).toBe(id);",
        "      expect(result.name).toBe('Updated ${name:pascal}');",
        "    });",
        "  });",
        "",
        "  describe('remove', () => {",
        "    it('should delete a ${name:camel}', async () => {",
        "      const id = ${name:pascal}Id('test-id');",
        "      const effect = ${name:pascal}Service.remove(id);",
        "      const result = await Effect.runPromise(effect);",
        "      ",
        "      expect(result).toBeDefined();",
        "      expect(result.success).toBe(true);",
        "    });",
        "  });",
        "});"
      ]
    },
    {
      "path": "${folder_name}/__tests__/${name:kebab}.hooks.test.ts",
      "content": [
        "/**",
        " * Tests for ${name:kebab}.hooks",
        " */",
        "import { renderHook, act } from '@testing-library/react-hooks';",
        "import { Effect, Either } from 'effect';",
        "import { use${name:pascal} } from '../${name:kebab}.hooks';",
        "import { ${name:pascal}Service } from '../${name:kebab}.service';",
        "import { ${name:pascal}Id } from '../types/${name:kebab}.type';",
        "",
        "// Mock the service",
        "jest.mock('../${name:kebab}.service', () => ({",
        "  ${name:pascal}Service: {",
        "    get: jest.fn()",
        "  }",
        "}));",
        "",
        "describe('use${name:pascal}', () => {",
        "  beforeEach(() => {",
        "    jest.clearAllMocks();",
        "  });",
        "",
        "  it('should return loading state initially', () => {",
        "    const id = ${name:pascal}Id('test-id');",
        "    const { result } = renderHook(() => use${name:pascal}(id));",
        "    ",
        "    expect(result.current.loading).toBe(true);",
        "    expect(result.current.${name:camel}).toBeNull();",
        "    expect(result.current.error).toBeNull();",
        "  });",
        "",
        "  it('should fetch ${name:camel} data and update state', async () => {",
        "    const id = ${name:pascal}Id('test-id');",
        "    const mockData = { id, name: 'Test ${name:pascal}' };",
        "    ",
        "    // Mock the service to return a successful Effect",
        "    (${name:pascal}Service.get as jest.Mock).mockReturnValue(",
        "      Effect.succeed(mockData)",
        "    );",
        "",
        "    const { result, waitForNextUpdate } = renderHook(() => use${name:pascal}(id));",
        "    await waitForNextUpdate();",
        "",
        "    expect(result.current.loading).toBe(false);",
        "    expect(result.current.${name:camel}).toEqual(mockData);",
        "    expect(result.current.error).toBeNull();",
        "    expect(${name:pascal}Service.get).toHaveBeenCalledWith(id);",
        "  });",
        "",
        "  it('should handle errors', async () => {",
        "    const id = ${name:pascal}Id('test-id');",
        "    const mockError = new Error('Failed to fetch');",
        "    ",
        "    // Mock the service to return a failed Effect",
        "    (${name:pascal}Service.get as jest.Mock).mockReturnValue(",
        "      Effect.fail(mockError)",
        "    );",
        "",
        "    const { result, waitForNextUpdate } = renderHook(() => use${name:pascal}(id));",
        "    await waitForNextUpdate();",
        "",
        "    expect(result.current.loading).toBe(false);",
        "    expect(result.current.${name:camel}).toBeNull();",
        "    expect(result.current.error).toEqual(mockError);",
        "  });",
        "});"
      ]
    },
    {
      "path": "${folder_name}/README.md",
      "content": [
        "# ${name:pascal} Module",
        "",
        "This module provides Effect-based functionality for managing ${name} entities.",
        "",
        "## Usage",
        "",
        "```typescript",
        "import { Effect } from 'effect';",
        "import { ${name:pascal}Service, use${name:pascal} } from './${name:kebab}';",
        "import { ${name:pascal}Id } from './types/${name:kebab}.type';",
        "",
        "// Using the Effect service directly",
        "const id = ${name:pascal}Id('some-id');",
        "const effect = ${name:pascal}Service.get(id);",
        "const result = await Effect.runPromise(effect);",
        "",
        "// Using the React hook",
        "const MyComponent = ({ id }) => {",
        "  const { ${name:camel}, loading, error } = use${name:pascal}(id);",
        "  ",
        "  if (loading) return <Spinner />;",
        "  if (error) return <ErrorMessage error={error} />;",
        "  if (!${name:camel}) return <NotFound />;",
        "  ",
        "  return <${name:pascal}Details ${name:camel}={${name:camel}} />;",
        "};",
        "```",
        "",
        "## Structure",
        "",
        "- `${name:kebab}.service.ts` - Effect-based service implementation",
        "- `${name:kebab}.hooks.ts` - React hooks for integrating with UI",
        "- `types/${name:kebab}.type.ts` - TypeScript type definitions with branded types",
        "- `__tests__/` - Unit tests",
        ""
      ]
    }
  ]
}